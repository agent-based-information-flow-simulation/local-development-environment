from __future__ import annotations

import copy
import datetime
import logging
import os
import random
import sys
from typing import TYPE_CHECKING, Any, Dict, List

import httpx
import numpy
import orjson
import spade

from src.settings.backup import backup_settings
from src.settings.communication_server import communication_server_settings

if TYPE_CHECKING:  # pragma: no cover
    from spade.agent import Agent
    from aioprocessing import AioQueue

logger = logging.getLogger(__name__)
logger.setLevel(level=os.environ.get("LOG_LEVEL_SIMULATION_CODE_GENERATION", "INFO"))


def remove_imports(agent_code_lines: List[str]) -> List[str]:
    return list(filter(lambda line: not line.startswith("import"), agent_code_lines))


def generate_agents(
    agent_code_lines: List[str], agent_data: List[Dict[str, Any]], agent_updates: AioQueue
) -> List[Agent]:
    agent_logger = logging.getLogger("agent")
    agent_logger.setLevel(level=os.environ.get("LOG_LEVEL_AGENT", "INFO"))

    code_without_imports = remove_imports(agent_code_lines)

    ###exec("\n".join(code_without_imports))
    """START OF CODE GENERATED BY THE SIMULATION"""
    ###
    ###
    class user(spade.agent.Agent):
        def __init__(self, jid, password, backup_url = None, backup_period = 60, backup_delay = 0, logger = None, **kwargs):
            super().__init__(jid, password, verify_security=False)
            if logger: logger.debug(f'[{jid}] Received parameters: jid: {jid}, password: {password}, backup_url: {backup_url}, backup_period: {backup_period}, backup_delay: {backup_delay}, kwargs: {kwargs}')
            self.logger = logger
            self.backup_url = backup_url
            self.backup_period = backup_period
            self.backup_delay = backup_delay
            self.connections = kwargs.get("connections", [])
            self.msgRCount = self.limit_number(kwargs.get("msgRCount", 0))
            self.msgSCount = self.limit_number(kwargs.get("msgSCount", 0))
            self.num_seen_photos = self.limit_number(kwargs.get("num_seen_photos", 0))
            self.friends = kwargs.get("friends", [])
            if self.logger: self.logger.debug(f'[{self.jid}] Class dict after initialization: {self.__dict__}')
        
        @property
        def connCount(self):
            return self.limit_number(len(self.connections))
        
        def limit_number(self, value):
            return float(max(-2147483648, min(value, 2147483647)))
        
        def get_json_from_spade_message(self, msg):
            return orjson.loads(msg.body)
        
        def get_spade_message(self, receiver_jid, body):
            msg = spade.message.Message(to=receiver_jid)
            body["sender"] = str(self.jid)
            msg.metadata["type"] = body["type"]
            msg.metadata["performative"] = body["performative"]
            msg.body = str(orjson.dumps(body), encoding="utf-8")
            return msg
        
        def setup(self):
            if self.backup_url:
                BackupBehaviour_template = spade.template.Template()
                BackupBehaviour_template.set_metadata("reserved", "no_message_match")
                self.add_behaviour(self.BackupBehaviour(start_at=datetime.datetime.now() + datetime.timedelta(seconds=self.backup_delay), period=self.backup_period), BackupBehaviour_template)
            initialize_template = spade.template.Template()
            initialize_template.set_metadata("reserved", "no_message_match")
            self.add_behaviour(self.initialize(), initialize_template)
            facebook_activity_template = spade.template.Template()
            facebook_activity_template.set_metadata("reserved", "no_message_match")
            self.add_behaviour(self.facebook_activity(period=30), facebook_activity_template)
            read_posts_template = spade.template.Template()
            read_posts_template.set_metadata("type", "facebook_post")
            read_posts_template.set_metadata("performative", "query")
            self.add_behaviour(self.read_posts(), read_posts_template)
            if self.logger: self.logger.debug(f'[{self.jid}] Class dict after setup: {self.__dict__}')
        
        class BackupBehaviour(spade.behaviour.PeriodicBehaviour):
            def __init__(self, start_at, period):
                super().__init__(start_at=start_at, period=period)
                self.http_client = httpx.AsyncClient(timeout=period)
            
            async def run(self):
                data = {
                    "__timestamp__": int(datetime.datetime.timestamp(datetime.datetime.utcnow())),
                    "jid": str(self.agent.jid),
                    "type": "user",
                    "floats": {
                        "msgRCount": self.agent.msgRCount,
                        "msgSCount": self.agent.msgSCount,
                        "connCount": self.agent.connCount,
                        "num_seen_photos": self.agent.num_seen_photos,
                    },
                    "enums": {
                    },
                    "connections": {
                        "connections": self.agent.connections,
                        "friends": self.agent.friends,
                    },
                    "messages": {
                    },
                    "float_lists": {
                    },
                }
                # if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Sending backup data: {data}')
                # try:
                #     await self.http_client.post(self.agent.backup_url, headers={"Content-Type": "application/json"}, data=orjson.dumps(data))
                # except Exception as e:
                #     if self.agent.logger: self.agent.logger.error(f'[{self.agent.jid}] Backup error type: {e.__class__}, additional info: {e}')
                    
                # ADDED
                # if self.agent.logger: self.agent.logger.info(f'[{self.agent.jid}] Sending backup data to queue')
                await agent_updates.coro_put(data)
                # if self.agent.logger: self.agent.logger.info(f'[{self.agent.jid}] Sent backup data to queue')

        class initialize(spade.behaviour.OneShotBehaviour):
            def initialize_friends(self):
                if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Run action initialize_friends')
                
                # float declaration
                max_friends = self.agent.limit_number(0)
                
                # length
                max_friends = self.agent.limit_number(len(self.agent.connections))
                
                # float declaration
                num_friends = self.agent.limit_number(0)
                
                # uniform distribution
                num_friends = self.agent.limit_number(random.uniform(self.agent.limit_number(0), self.agent.limit_number(max_friends)))
                
                # round
                num_friends = self.agent.limit_number(round(self.agent.limit_number(num_friends)))
                
                # subset
                if int(self.agent.limit_number(round(self.agent.limit_number(num_friends)))) <= 0:
                    if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Non-positive subset size (rounded): {int(self.agent.limit_number(round(self.agent.limit_number(num_friends))))}')
                    return
                self.agent.friends = [copy.deepcopy(elem) for elem in random.sample(self.agent.connections, min(int(self.agent.limit_number(round(self.agent.limit_number(num_friends)))), int(self.agent.limit_number(len(self.agent.connections)))))]
            
            async def run(self):
                self.initialize_friends()
        
        class facebook_activity(spade.behaviour.PeriodicBehaviour):
            async def post_photos(self):
                if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Run action post_photos')
                send = { "type": "facebook_post", "performative": "query", "photos": 0.0, }
                
                # float declaration
                num_photos = self.agent.limit_number(0)
                
                # uniform distribution
                num_photos = self.agent.limit_number(random.uniform(self.agent.limit_number(21), self.agent.limit_number(37)))
                
                # round
                num_photos = self.agent.limit_number(round(self.agent.limit_number(num_photos)))
                
                # set
                send["photos"] = self.agent.limit_number(num_photos)
                
                # send
                if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Send message {send} to {self.agent.friends}')
                for receiver in self.agent.friends:
                    await self.send(self.agent.get_spade_message(receiver, send))
                    self.agent.msgSCount = self.agent.limit_number(self.agent.msgSCount + 1)
            
            async def run(self):
                await self.post_photos()
        
        class read_posts(spade.behaviour.CyclicBehaviour):
            def update_seen_photos(self, rcv):
                if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Run action update_seen_photos')
                
                # add
                self.agent.num_seen_photos = self.agent.limit_number(self.agent.num_seen_photos + self.agent.limit_number(rcv["photos"]))
            
            async def run(self):
                rcv = await self.receive(timeout=100000)
                if rcv:
                    rcv = self.agent.get_json_from_spade_message(rcv)
                    self.agent.msgRCount = self.agent.limit_number(self.agent.msgRCount + 1)
                    if self.agent.logger: self.agent.logger.debug(f'[{self.agent.jid}] Received message: {rcv}')
                    self.update_seen_photos(rcv)
    
    ###                
    """END OF CODE GENERATED BY THE TRANSLATOR"""
    ###
    
    agents = []
    for agent_data_dict in agent_data:
        agent_type = agent_data_dict["type"]
        del agent_data_dict["type"]
        agent = locals()[agent_type](
            password=communication_server_settings.password,
            backup_url=backup_settings.agent_backup_url,
            backup_period=backup_settings.period,
            backup_delay=backup_settings.delay,
            logger=agent_logger,
            **agent_data_dict,
        )
        agents.append(agent)

    logger.debug(f"Initialized agents: {agents}")

    return agents
